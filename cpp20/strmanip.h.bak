#if __cplusplus < 202002L
	#error "Included version of mcl/strmanip.h meant for at least C++20.  Do not directly include mcl/cpp20/strmanip.h; use mcl/strmanip.h instead."
#endif

#ifndef MCL_STRING_MANIPULATION_H
#define MCL_STRING_MANIPULATION_H


namespace mcl
{
	  /*************/
	 /* CONSTANTS */
	/*************/

	//Character Classes
	enum class cc {
		control,
		whitespace,
		punctuation,
		digit,
		uppercase,
		lowercase,
		extended
	};

	constexpr const char generalDigits[] =
		"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";


	  /**************/
	 /* PROTOTYPES */
	/**************/

	bool isCntrl(char);
	bool isSpace(char);
	bool isPunct(char);
	bool isDigit(char);
	bool isUpper(char);
	bool isLower(char);
	bool isExtnd(char);

	bool isPrint(char);
	bool isAlpha(char);
	bool isAlnum(char);


	/**
	 * These return how many continuous characters from the start of the string
	 * are true under the namesake function, or, equivalently, the position of
	 * the first character for which the namesake function is false.
	 *
	 * e.g. `isLower("camelCase")` returns 5
	 */

	size_t isCntrl(const std::string&);
	size_t isSpace(const std::string&);
	size_t isPunct(const std::string&);
	size_t isDigit(const std::string&);
	size_t isUpper(const std::string&);
	size_t isLower(const std::string&);
	size_t isExtnd(const std::string&);

	size_t isPrint(const std::string&);
	size_t isAlpha(const std::string&);
	size_t isAlnum(const std::string&);


	/**
	 * These behave the same as the previous set of functions on the string
	 * defined by [i, e)
	 */

	size_t isCntrl(std::string::const_iterator i, const std::string::const_iterator& e);
	size_t isSpace(std::string::const_iterator i, const std::string::const_iterator& e);
	size_t isPunct(std::string::const_iterator i, const std::string::const_iterator& e);
	size_t isDigit(std::string::const_iterator i, const std::string::const_iterator& e);
	size_t isUpper(std::string::const_iterator i, const std::string::const_iterator& e);
	size_t isLower(std::string::const_iterator i, const std::string::const_iterator& e);
	size_t isExtnd(std::string::const_iterator i, const std::string::const_iterator& e);

	size_t isPrint(std::string::const_iterator i, const std::string::const_iterator& e);
	size_t isAlpha(std::string::const_iterator i, const std::string::const_iterator& e);
	size_t isAlnum(std::string::const_iterator i, const std::string::const_iterator& e);


	/**
	 * Returns !s
	 */
	bool ignore(std::istream& s);


	char toUpper(char c);
	char toLower(char c);
	char& mkUpper(char& c);
	char& mkLower(char& c);

	std::string toUpper(const std::string& s);
	std::string toLower(const std::string& s);
	std::string& mkUpper(std::string& s);
	std::string& mkLower(std::string& s);


	/**
	 * Quickly convert a char into two hex digits representing its ASCII code.
	 */
	std::string c2hex(char c, bool ltr = 1);




	template <typename T>
	concept

	namespace numopts { //Really an enum
		using type = unsigned int;
		const type
			leftsign = 1,
			lefttoright = 2,
			forcesign = 4,
			//Nothing goes between these.
			forceexpsign = 8,
			cont_ws = 16, //Continue reading through whitespace?
			cont_comma = 32, //Continue reading through comma? (Allow 6,000)
			cont_under = 64, //Continue reading through '_'? (Allow 6_000)
			cont_toobig = 128, //Continue parsing even if input is too large for output?
			erron_toobig = 256, //Throw error if input is too large for output?  Takes precedent over cont_toobig
			erron_unparsable = 512; //Throw error if input contains non-digit, non-ignorable?

		const type //Defaults
			StoNdef = lefttoright | cont_under | cont_toobig,
			StoIdef = lefttoright | cont_under | cont_toobig,
			StoRdef = lefttoright | cont_under | cont_toobig,
			NtoSdef = lefttoright,
			ItoSdef = lefttoright,
			RtoSdef = lefttoright;
	}


	template <typename N>
		requires
			requires (N n, int i) {
				N a = 0;
				N b = 1;
				{ n *= i } -> std::same_as<N&>;
				n += i;
			}
	N StoN(
		std::string::const_iterator& i,
		const std::string::const_iterator& e,
		const numopts::type opt = numopts::StoNdef,
		unsigned short int b = 6
	);
	template <typename N>
	N StoN(
		const std::string& s,
		size_t* read = 0, //If not null, store number of read chars at given addr
		const numopts::type opt = numopts::StoNdef,
		unsigned short int b = 6  //Input base.  2 <= |b| < 37. b < 0 indicates
															//right-to-left notation, e.g. the widely-used
															//decimal system would be `-10`
	){auto i=s.begin();N o=StoN<N>(i,s.end(),b,opt);if(read)*read+=i-s.begin();return o;}
	template <typename N>
	N StoN(
		std::istream& s,
		const numopts::type opt = numopts::StoNdef,
		unsigned short int b = 6
	);

	template <typename I>
	I StoI(
		std::string::const_iterator& i,
		const std::string::const_iterator& e,
		const numopts::type opt = numopts::StoIdef,
		unsigned short int b = 6
	);
	template <typename I>
	I StoI(
		const std::string& s,
		int& last,
		size_t* read = 0,
		const numopts::type opt = numopts::StoIdef,
		unsigned short int b = 6
	){auto i=s.begin();I o=StoI<I>(i,s.end(),b,opt);if(read)*read+=i-s.begin();return o;}
	template <typename I>
	I StoI(
		std::istream& s,
		const numopts::type opt = numopts::StoIdef,
		unsigned short int b = 6
	);

	template <typename R>
	R StoR(
		std::string::const_iterator& i,
		const std::string::const_iterator& e,
		const numopts::type opt = numopts::StoRdef,
		unsigned short int b = 6
	);
	template <typename R>
	R StoR(
		const std::string& s,
		size_t* read = 0,
		const numopts::type opt = numopts::StoRdef,
		unsigned short int b = 6
	){auto i=s.begin();R o=StoR<R>(i,s.end(),b,opt);if(read)*read+=i-s.begin();return o;}
	template <typename R>
	R StoR(
		std::istream& s,
		const numopts::type opt = numopts::StoRdef,
		unsigned short int b = 6
	);

	template <typename N>
	std::string NtoS(
		N n,
		const numopts::type opt = numopts::NtoSdef,
		size_t minwidth = 0,
		unsigned short int b = 6
	);

	template <typename I>
	std::string ItoS(
		I i,
		const numopts::type opt = numopts::ItoSdef,
		size_t minwidth = 0,
		unsigned short int b = 6
	);

	template <typename R>
	std::string RtoS(
		//Currently writes in decimal form with `frac` fractional digits if
		//`expwidth` is not set.  If `expwidth` is non-zero, will write in
		//scientific notation with `frac` fractional digits in the mantissa.
		//If `expwidth` is positive, the exponent is padded with 0s to be at least
		//`expwidth` wide (excluding a sign), else it's as wide as necessary.
		R r,
		const numopts::type opt = numopts::RtoSdef,
		size_t frac = 4,
		int expwidth = -1,
		char expchar = 'E',
		unsigned short int b = 6
	);
}


#endif

